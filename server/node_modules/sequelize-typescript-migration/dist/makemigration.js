"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sequelize_typescript_1 = require("sequelize-typescript");
const fs = require("fs");
const beautify = require("js-beautify");
const constants_1 = require("./constants");
const parseArgs_1 = require("./utils/parseArgs");
const getTablesFromModels_1 = require("./utils/getTablesFromModels");
const getDiffActionsFromTables_1 = require("./utils/getDiffActionsFromTables");
const getMigration_1 = require("./utils/getMigration");
const createMigrationTable_1 = require("./utils/createMigrationTable");
const getLastMigrationState_1 = require("./utils/getLastMigrationState");
const writeMigration_1 = require("./utils/writeMigration");
const bootstrap = async () => {
    if (process.env.NODE_ENV != "local") {
        console.log("로컬에서만 진행 가능합니다.");
        process.exit(0);
    }
    const program = parseArgs_1.default(process.argv);
    let sequelizeRc = {};
    try {
        sequelizeRc = require(constants_1.sequelizeRcPath);
    }
    catch (err) {
        console.log(`it must need .sequelizerc file !!, not exists in ${constants_1.sequelizeRcPath}.`);
        process.exit(0);
    }
    const configPath = sequelizeRc.config;
    const modelsPath = program.modelsPath || sequelizeRc["models-path"];
    const migrationsPath = program.migrationsPath || sequelizeRc["migrations-path"];
    const pathsToCheck = [
        {
            path: configPath,
            msg: `Invalid config path. do 'npx sequelize init' first.`,
        },
        {
            path: modelsPath,
            msg: `Invalid model path (${modelsPath})`,
        },
        {
            path: migrationsPath,
            msg: `Invalid migration path (${migrationsPath})`,
        },
    ];
    pathsToCheck.forEach(value => {
        if (value.path === undefined || fs.existsSync(value.path) === false) {
            console.log(value.msg);
            process.exit(0);
        }
    });
    let sequelizeConfig;
    try {
        sequelizeConfig = require(configPath)[process.env.NODE_ENV];
        sequelizeConfig.logging = false;
    }
    catch (err) {
        console.log(`it must need .sequelizerc file !!, not exists in ${configPath}.`);
        process.exit(0);
    }
    const sequelize = new sequelize_typescript_1.Sequelize(sequelizeConfig);
    const models = sequelize.models;
    await sequelize.authenticate();
    const queryInterface = sequelize.getQueryInterface();
    await createMigrationTable_1.default(sequelize);
    const lastMigrationState = await getLastMigrationState_1.default(sequelize);
    const previousState = {
        revision: lastMigrationState !== undefined ? lastMigrationState["revision"] : 0,
        version: lastMigrationState !== undefined ? lastMigrationState["version"] : 1,
        tables: lastMigrationState !== undefined ? lastMigrationState["tables"] : {},
    };
    const currentState = {
        revision: previousState.revision + 1,
        tables: getTablesFromModels_1.default(sequelize, models),
    };
    const upActions = getDiffActionsFromTables_1.default(previousState.tables, currentState.tables);
    const downActions = getDiffActionsFromTables_1.default(currentState.tables, previousState.tables);
    const migration = getMigration_1.default(upActions);
    const tmp = getMigration_1.default(downActions);
    migration.commandsDown = tmp.commandsUp;
    if (migration.commandsUp.length === 0) {
        console.log("No changes found");
        process.exit(0);
    }
    migration.consoleOut.forEach(v => {
        console.log(`[Actions] ${v}`);
    });
    if (program.preview) {
        console.log("Migration result:");
        console.log(beautify(`[ \n${migration.commandsUp.join(", \n")} \n];\n`));
        console.log("Undo commands:");
        console.log(beautify(`[ \n${migration.commandsDown.join(", \n")} \n];\n`));
        return 1;
    }
    const info = await writeMigration_1.default(currentState.revision, migration, migrationsPath, program);
    console.log(`New migration to revision ${currentState.revision} has been saved to file '${info.filename}'`);
    const rows = [
        {
            revision: currentState.revision,
            name: info.info.name,
            state: JSON.stringify(currentState),
        },
    ];
    try {
        await queryInterface.bulkDelete("SequelizeMetaMigrations", {
            revision: currentState.revision,
        });
        await queryInterface.bulkInsert("SequelizeMetaMigrations", rows);
        if (program.verbose) {
            console.log("Updated state on DB.");
        }
        console.log(`Use sequelize CLI:
  npx sequelize db:migrate --to ${info.revisionNumber}-${info.info.name}.js ${program.migrationsPath
            ? `--migrations-path=${program.migrationsPath}`
            : ""} ${program.modelsPath ? `--models-path=${program.modelsPath}` : ""}`);
        return 0;
    }
    catch (err) {
        if (program.debug)
            console.error(err);
    }
    return 1;
};
bootstrap();
//# sourceMappingURL=makemigration.js.map